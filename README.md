# Pacman

We created a version of Pacman in SystemVerilog, simulating real-time game logic on FPGA hardware. For our game, we decided that we would have a maze, a pacman that would be controlled with the keyboard, four ghosts that would move based on AI algorithms we would create, food dots for pacman to collect, and power-ups. We also wanted pacman to have three lives and for the game to be over either after pacman loses all his lives or he collects all the food.

Our version of Pac Man was developed mainly in System Verilog. The only C code used in our programme is to receive the keyboard controls and pass them into the top level of the project in Vivado. This meant that we had working keyboard controls which would be used to move pacman around the map. The difficulty with developing our game solely in hardware was that it used up a lot more resources than had we chosen to use software. 

Pacman is controlled by the user using the “AWSD” keys of a keyboard. Pacman can only move up, left, right or down. Pacman is not able to cross a boundary. Boundary conditions are checked by using the ROM that contains the coordinates of each pixel that makes up the map. It pacman’s top, right, left or bottom boundary overlaps with the boundary of the map, pacman will simply jump back and stop moving. Pacman has a state machine which gives it three lives. If Pacman collides with a ghost and a flag is set, one of Pacman’s lives is lost and the game resets with each character back in their original starting position. If Pacman loses three lives, the game ends with a “GAME OVER” appearing on the screen. If Pacman moves into the boundary tunnel, it is able to pass through to the other side of the screen. This is done by giving Pacman a new set coordinate once it goes past a certain point of the X-axis.

Similar to the original Pac Man game, each of the four ghosts have two states; scatter and chase. When the ghosts are in the scatter state, they will move towards one of the four corners of the map. Once a ghost is in the chase state, it will calculate the distance between itself and pac man, then determine if one pixel left, one pixel right, one pixel up or one pixel down will give it the closest distance to pac man. The order of the distances is then arranged so the ghost knows which distance is shortest up to which distance is longest. It then determines whether it can move in the direction of the shortest path. If there is a boundary in that direction one pixel ahead, the ghost will then look at the second shortest distance to see if there is a boundary in that direction. This continues until the ghost can find a direction to move towards. Once the ghost reaches the next pixel it will re-calculate each distance with respect to Pacman’s new location.  Each ghost follows the same logic for chase. However, each ghost has its own finite state machine which is attached to a counter. This means that there is always a ghost in the chase state. The ghosts are set to leave their base with a staggered exit. The red ghost will leave as soon as the first keycode for pacman is pressed. This also begins a counter so the other three ghosts know when to leave.  If one of the ghosts is in the same location as pacman this sets off a flag which causes pacman to lose a life, while all the ghosts are reset to their original starting location.

If Pacman’s coordinates overlap with the coordinates of the food, this will set off a flag to turn off that food dot so that it no longer appears on the screen. If Pacman goes over the coordinate and the flag has not yet been raised, this will increment a counter which is used to show the score. If all the food dots have been collected, Pacman has won the game and “YOU WIN” is projected onto the screen. To accurately project the score count of the screen, two variables, digit one and digit two, were created. Each was four bits and started their count at 0. Digit one was fed the value of the counter. If the counter reached 10, it was reset and the value of digit two was increased by one. 
